# 계획

## . **다크모드/라이트모드 전환 기능**

- **이유**: 다크모드와 라이트모드는 현대 웹사이트와 앱의 필수 기능 중 하나입니다.
- **구현 포인트**:
  - 사용자의 선택을 **로컬 스토리지에 저장**해, 페이지를 새로고침하거나 재방문해도 선택이 유지되도록 합니다.
  - Tailwind CSS 또는 Styled-Components로 **테마 색상 변경**.
- **추가 확장**: 다크모드와 라이트모드 외에 커스텀 테마 모드를 추가해보세요.

---

## 2. **드래그 앤 드롭(Drag-and-Drop) UI**

- **이유**: 사용자가 요소를 자유롭게 배치할 수 있는 **드래그 앤 드롭 인터페이스**는 대시보드나 관리자 페이지에서 많이 사용됩니다.
- **구현 포인트**:
  - React의 `react-dnd` 라이브러리를 활용해 리스트나 카드 컴포넌트를 드래그해서 정렬합니다.
  - **드래그 후의 상태를 로컬 스토리지나 상태관리(store)에 저장**하여, 재배치된 상태가 유지되도록 구현합니다.
- **추가 확장**: Trello 스타일의 **칸반 보드**를 만들어도 좋습니다.

---

## 3. **인피니트 스크롤(Infinite Scroll)**

- **이유**: 소셜 미디어나 쇼핑몰처럼 **많은 데이터를 로드할 때 성능 최적화**를 위해 필수적입니다.
- **구현 포인트**:
  - Intersection Observer API 또는 `react-infinite-scroll-component`를 사용해, 스크롤이 끝나면 다음 데이터를 자동으로 불러옵니다.
  - **API와 연동**하여 데이터를 점진적으로 로드합니다.
- **추가 확장**: 데이터가 로딩되는 동안 **로딩 스켈레톤 UI**를 추가해 사용자 경험을 개선합니다.

---

## 4. **모달 시스템 구현 (Modal System)**

- **이유**: 팝업 모달은 로그인, 알림, 피드백 창 등 다양한 곳에서 사용됩니다.
- **구현 포인트**:
  - **중첩 모달 처리**(모달 안에 모달 열기)를 위한 구조 설계.
  - **Portal**을 사용해 모달을 DOM 최상단에 렌더링.
- **추가 확장**: 애니메이션 효과를 추가하거나 **모바일 반응형 모달**을 구현해보세요.

---

## 5. **반응형 네비게이션 바 구현**

- **이유**: 대부분의 웹사이트와 앱에서 필수적인 요소입니다.
- **구현 포인트**:
  - **모바일 화면에서 햄버거 메뉴**로 변경되는 반응형 UI를 구현합니다.
  - `useState`와 CSS 트랜지션을 활용해 메뉴의 열고 닫기 애니메이션을 추가합니다.
- **추가 확장**: 로그인 상태에 따라 **다른 메뉴를 표시**하거나, 모드에 맞춘 네비게이션 스타일을 적용합니다.

---

### 최종 추천: **다크모드 + 드래그 앤 드롭 칸반 보드**

이 두 가지를 결합하면 유저들이 체감할 수 있는 인터랙티브한 기능을 빠르게 구현할 수 있습니다. **드래그 가능한 칸반 보드에서 다크모드 전환 기능까지 적용**해보세요. 이를 통해 다양한 UI 요소와 상태관리를 한 번에 연습할 수 있습니다.

# 정리

### **개발 일지: 다크모드/라이트모드 구현**

---

## 1. **단계별로 적용한 내용**

### 1단계: 프로젝트 구조 설계

- `ThemeContext.tsx`: 테마 전환을 관리할 **Context API** 파일을 생성.
- `themes.css`: **다크모드와 라이트모드 스타일**을 정의한 CSS 파일 생성.
- `ThemeToggle.tsx`: 사용자가 테마를 변경할 수 있는 **버튼 컴포넌트** 제작.
- `App.tsx`: 애플리케이션 전체에 테마 설정을 적용하기 위해 **ThemeProvider**로 감쌈.

---

### 2단계: ThemeContext 생성 및 상태 관리

- **Context API**를 활용해 **다크모드와 라이트모드 상태**를 전역으로 관리하도록 구현.
- 초기 테마를 **로컬 스토리지**에서 불러와 페이지 새로고침 후에도 유지되도록 설정.
- 테마 전환 시 **`document.body.className`**을 수정하여 CSS 변경 적용.

---

### 3단계: CSS 스타일 작성

- **CSS 변수**(`--bg-color`, `--text-color`)를 활용해 다크모드/라이트모드에 따른 색상 정의.
- 다크모드와 라이트모드 전환 시 부드러운 **트랜지션 효과** 적용.

---

### 4단계: ThemeToggle 버튼 제작

- 클릭 시 **테마를 전환하는 함수**(`toggleTheme`)가 호출되도록 이벤트 연결.
- 현재 테마 상태에 따라 버튼 텍스트가 **"Dark Mode"** 또는 **"Light Mode"**로 변경되도록 구현.

---

## 2. **사용된 기술 및 기능에 대한 소개 및 공부**

### **Context API**

- Context API는 **전역 상태 관리**를 위해 사용되는 React 기능입니다.
- props를 여러 컴포넌트에 전달하지 않고, **Context**를 통해 필요한 곳에서 전역 상태에 접근할 수 있습니다.

### **로컬 스토리지 (LocalStorage)**

- **브라우저에 데이터를 저장**하는 기능으로, 사용자가 선택한 테마를 저장해 새로고침 후에도 설정이 유지되도록 활용했습니다.

### **CSS 변수와 트랜지션**

- **CSS 변수**를 통해 테마별 색상 관리가 간편해졌으며, CSS 트랜지션을 사용해 **부드러운 전환 효과**를 구현했습니다.

---

## 3. **Context 흐름: 적용된 다크모드의 Context 동작 원리**

### **ThemeContext 구성 및 흐름**

1. **Context 생성**:

   tsx

   코드 복사

   `const ThemeContext = createContext<ThemeContextType | undefined>(undefined);`

   - 이 코드는 테마 상태와 테마 전환 함수를 관리하기 위한 **컨텍스트 객체**를 만듭니다.

2. **ThemeProvider 구현**:

   - **`ThemeProvider`**는 애플리케이션 전체를 감싸고, 자식 컴포넌트들이 테마 상태와 전환 함수를 사용할 수 있도록 합니다.
   - 로컬 스토리지에서 테마를 불러와 `document.body.className`에 적용하는 **`useEffect`**가 포함됩니다.

   tsx

   코드 복사

   `const [theme, setTheme] = useState<Theme>('light'); useEffect(() => {   const savedTheme = localStorage.getItem('theme') as Theme;   if (savedTheme) {     setTheme(savedTheme);     document.body.className = savedTheme;   } }, []);`

3. **테마 전환 함수 (`toggleTheme`)**:

   - 사용자가 버튼을 클릭할 때 호출됩니다. 새로운 테마를 적용하고, 이를 로컬 스토리지에 저장합니다.

   tsx

   코드 복사

   `const toggleTheme = () => {   const newTheme = theme === 'light' ? 'dark' : 'light';   setTheme(newTheme);   document.body.className = newTheme;   localStorage.setItem('theme', newTheme); };`

4. **Context 값을 제공**:

   - `ThemeProvider`는 **현재 테마 상태와 전환 함수**를 `value`로 제공하여, 자식 컴포넌트들이 이를 사용할 수 있게 합니다.

   tsx

   코드 복사

   `<ThemeContext.Provider value={{ theme, toggleTheme }}>   {children} </ThemeContext.Provider>`

5. **`useTheme` 훅을 통한 Context 사용**:

   - **`useContext`**를 활용해 컴포넌트에서 테마 상태에 접근하고, 테마를 전환할 수 있습니다.
   - 만약 `ThemeContext`가 제대로 감싸지지 않았다면 에러를 던지도록 설정했습니다.

   tsx

   코드 복사

   `export const useTheme = () => {   const context = useContext(ThemeContext);   if (!context) throw new Error('useTheme must be used within a ThemeProvider');   return context; };`

---

## 4. **결론 및 회고**

- **Context API를 활용한 전역 테마 관리**를 구현하며, Context의 흐름과 상태 관리에 대한 이해를 높였습니다.
- 단순한 **로컬 스토리지** 연동을 통해 사용자가 테마를 변경해도 지속성을 유지할 수 있었습니다.
- 이번 작업을 통해 **Context API의 유용성**을 체험했으며, 향후 **다른 전역 상태 관리**에도 이를 응용할 수 있을 것으로 보입니다.

---

## 5. **향후 개선 방향**

- **애니메이션 개선**: 테마 전환 시 배경이 자연스럽게 변화하도록 애니메이션 효과를 추가할 계획입니다.
- **더 많은 테마 제공**: 유저가 직접 색상을 선택해 커스텀 테마를 생성하고 저장할 수 있는 기능을 추가할 예정입니다.
- **전역 상태 관리 도구와 연계**: Redux나 Zustand와 같은 도구와 Context API를 함께 사용해 더 복잡한 상태 관리 시나리오에 대비해보겠습니다.
